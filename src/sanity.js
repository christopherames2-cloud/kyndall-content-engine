// Sanity CMS Service
// ALL POSTS ARE CREATED AS DRAFTS

import { createClient } from '@sanity/client'

let client = null

export function initSanity(projectId, dataset, token) {
  client = createClient({
    projectId,
    dataset,
    token,
    apiVersion: '2024-01-01',
    useCdn: false
  })
}

export async function getAdminSettings() {
  if (!client) return { notificationEmail: 'hello@kyndallames.com', discountExpirationDays: 14 }
  const query = `*[_type == "adminSettings"][0]`
  const settings = await client.fetch(query)
  return settings || { notificationEmail: 'hello@kyndallames.com', discountExpirationDays: 14 }
}

export async function updateAdminStats(stats) {}

export async function checkIfVideoProcessed(videoId) {
  if (!client) throw new Error('Sanity client not initialized')
  const query = `*[_type == "blogPost" && videoId == $videoId][0]`
  const result = await client.fetch(query, { videoId })
  return !!result
}

async function uploadImageFromUrl(imageUrl, filename) {
  if (!imageUrl || !client) return null
  try {
    console.log(`      Downloading thumbnail...`)
    const response = await fetch(imageUrl)
    if (!response.ok) return null
    const arrayBuffer = await response.arrayBuffer()
    const buffer = Buffer.from(arrayBuffer)
    console.log(`      Uploading to Sanity...`)
    const asset = await client.assets.upload('image', buffer, {
      filename: filename || 'thumbnail.jpg',
      contentType: 'image/jpeg'
    })
    console.log(`      âœ“ Thumbnail uploaded`)
    return {
      _type: 'image',
      asset: { _type: 'reference', _ref: asset._id }
    }
  } catch (error) {
    console.error(`      Thumbnail upload failed:`, error.message)
    return null
  }
}

export async function createDraftBlogPost({ video, analysis, productLinks }) {
  if (!client) throw new Error('Sanity client not initialized')

  let thumbnailAsset = null
  if (video.thumbnail) {
    thumbnailAsset = await uploadImageFromUrl(video.thumbnail, `${video.id}-thumb.jpg`)
  }

  let content = analysis.blogContent || ''
  for (const productLink of productLinks) {
    const placeholder = `[PRODUCT_LINK:${productLink.name}]`
    content = content.replace(placeholder, `**${productLink.name}**`)
  }

  // Log product details
  console.log(`      ðŸ“¦ Saving ${productLinks.length} products:`)
  productLinks.forEach(p => {
    console.log(`         - ${p.brand} ${p.name}`)
    if (p.originalUrl) console.log(`           Original URL: ${p.originalUrl}`)
    if (p.shopmyUrl) console.log(`           ShopMy: ${p.shopmyUrl}`)
  })

  // CREATE AS DRAFT
  const doc = {
    _type: 'blogPost',
    status: 'draft',
    title: analysis.blogTitle,
    slug: { _type: 'slug', current: generateSlug(analysis.blogTitle) },
    seoTitle: analysis.seoTitle,
    seoDescription: analysis.seoDescription,
    excerpt: analysis.blogExcerpt,
    category: analysis.category?.toLowerCase() || 'lifestyle',
    platform: video.platform?.toLowerCase() || 'youtube',
    videoUrl: video.url,
    videoId: video.id,
    thumbnail: thumbnailAsset,
    thumbnailUrl: video.thumbnail || null,
    views: video.viewCount ? `${formatViews(video.viewCount)} views` : undefined,
    content: [{
      _type: 'block',
      _key: generateKey(),
      style: 'normal',
      markDefs: [],
      children: [{ _type: 'span', _key: generateKey(), text: content, marks: [] }]
    }],
    productsReviewed: false,
    productLinks: productLinks.map(p => ({
      _type: 'productItem',
      _key: generateKey(),
      name: p.name,
      brand: p.brand,
      productType: p.type || 'other',
      // Use originalUrl from YouTube description if available, otherwise ShopMy
      hasShopmy: (p.shopmyUrl || p.originalUrl) ? 'yes' : 'pending',
      shopmyUrl: p.shopmyUrl || p.originalUrl || null,
      // Amazon - use the search link as suggestion
      hasAmazon: 'pending',
      suggestedAmazonSearch: p.amazonUrl,
      amazonUrl: null,
      // Keep original URL for reference
      originalUrl: p.originalUrl || null,
      reviewed: false,
    })),
    suggestedTags: analysis.suggestedTags || [],
    publishedAt: new Date().toISOString(),
    autoGenerated: true,
    sourceVideo: {
      id: video.id,
      title: video.title,
      platform: video.platform,
      publishedAt: video.publishedAt
    }
  }

  console.log(`      âš ï¸  Creating post with status: "${doc.status}"`)
  
  const result = await client.create(doc)
  
  // DOUBLE CHECK - patch to ensure draft status
  await client.patch(result._id).set({ status: 'draft' }).commit()
  
  console.log(`      âœ“ Created as DRAFT (ID: ${result._id})`)
  
  return result
}

export async function getExpiringCodes(daysAhead = 14) {
  if (!client) return []
  const today = new Date()
  const futureDate = new Date()
  futureDate.setDate(today.getDate() + daysAhead)
  const todayStr = today.toISOString().split('T')[0]
  const futureDateStr = futureDate.toISOString().split('T')[0]
  const query = `*[_type == "discountCode" && active == true && expirationDate != null && expirationDate >= $today && expirationDate <= $futureDate && reminderSent != true] | order(expirationDate asc) {
    _id, brand, code, discount, expirationDate, brandContact
  }`
  const codes = await client.fetch(query, { today: todayStr, futureDate: futureDateStr })
  return codes.map(code => {
    const expDate = new Date(code.expirationDate)
    const daysUntil = Math.ceil((expDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24))
    return { ...code, daysUntilExpiration: daysUntil }
  })
}

export async function markReminderSent(codeId) {
  if (!client) return false
  try {
    await client.patch(codeId).set({ reminderSent: true }).commit()
    return true
  } catch (e) { return false }
}

export async function runCleanup() {
  console.log('   Cleanup: skipped')
}

function generateSlug(title) {
  return title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '').substring(0, 96)
}

function generateKey() {
  return Math.random().toString(36).substring(2, 10)
}

function formatViews(count) {
  const num = parseInt(count)
  if (num >= 1000000) return `${(num / 1000000).toFixed(1)}M`
  if (num >= 1000) return `${(num / 1000).toFixed(0)}K`
  return num.toString()
}
